server
{
    listen 80;
  # This will make sure that any changes to the lua code file is picked up
  # without reloading or restarting nginx
  lua_code_cache off;
#    server_name test.example.com;
set $resp_body '';
    location /
    {
       
            content_by_lua_block
            {
                ngx.req.read_body()
                local req = ngx.req.get_body_data()
                local newreq, n, err = ngx.re.gsub(req, "REPLACE", "REPLACED")
                ngx.req.set_body_data(newreq)
                ngx.print(ngx.req.get_body_data())
                ngx.print(ngx.req.get_headers()['X-Real-IP'])
                ngx.print(ngx.req.set_body_data(newreq))
                -- grab the POST parameters as a table
                local params = ngx.req.get_body_data()
                ngx.print(params)          

            }
        

 #       include proxy_params;
 #       proxy_pass http://127.0.0.1:8181/;
    }

    location /send
    {
       
        

 #       include proxy_params;
       proxy_pass http://172.19.0.2:80/;
    }

    location = /request_body {
         client_max_body_size 50k;
         client_body_buffer_size 50k;

         content_by_lua_block {
            -- function remove_user_key()
                ngx.req.read_body()
                -- log the original body so we can compare to the new one later
                local oldbody = ngx.req.get_body_data()
                --log(oldbody)
                -- grab the POST parameters as a table
                local params = ngx.req.get_post_args()

                -- build up the new JSON string
                local newbody = "{"

                for k,v in pairs(params) do
                    -- add all the params we want to keep
                    if k ~= "user_key" then
                        log("adding"..k.." as "..v)
                        newbody = newbody..'"'..k..'":"'..v..'",'
                    else 
                --        log("not adding user_key")
                    end
                end
                --remove the last trailing comma before closing this off
                newbody = string.sub(newbody, 0, #newbody-1)
                newbody = newbody.."}"

                ngx.req.set_body_data(newbody)
            --    log(newbody)
            --    end

            --    if ngx.req.get_method() == "POST" then
            --    remove_user_key()
            --    end
         }
  
 #       include proxy_params;
 #       proxy_pass http://127.0.0.1:8181/;
    }
    location /foo {
            access_by_lua '
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            body = string.gsub(body, "INFO", "ERROR")
            ngx.req.set_body_data(body)
            local header = ngx.req.get_headers()["Content-Type"]
            header = string.gsub(header, "INFO", "ERROR")
            ngx.req.set_header("Content-Type", header)
        ';
        proxy_pass http://127.0.0.1:8181/;
        log_by_lua_block {
         ngx.log(ngx.CRIT, "See if this message comes")
       }
    }

    location /foo2 {
                #host and port to fastcgi server
                default_type text/html;
                set $URL "http://$http_host$request_uri";
                set $foo '';
                set $query "";
                set $response_body '';
                lua_need_request_body on;
                         content_by_lua_block {
                            local headers = ngx.req.get_headers()
                            for k, v in pairs(headers) do
                                ngx.log(ngx.ERR,"headerK = "..k..' value = '..v)
                                ngx.say("headerK = "..k..' value = '..v)
                            end

                            ngx.req.read_body() -- explicitly read the req body
                            local req = ngx.req.get_body_data()
                            ngx.say("req data:")
                            ngx.print(req)

                            -- Test
                            cjson = require "cjson"
                            ngx.req.read_body()
                            body_table = cjson.decode(ngx.var.request_body)
                            ngx.var.foo = body_table["foo"]
                            ngx.say("body_table data:")
                            ngx.print(ngx.var.foo)

                            local newreq, n, err = ngx.re.gsub(req, "INFO", "REPLACED")
                            ngx.req.set_body_data(newreq) 
                            ngx.say("newreq data:")
                            ngx.print(newreq)

                            ps = {"Player1","Player2","Player3","Player4"}
                                local teams={{},{},{}}

                                --[[for name,player in pairs(tfm.get.room.playerList) do
                                table.insert(ps,name)
                                end]]

                                table.sort(ps,function() return math.random()>0.5 end)
                                for i,player in ipairs(ps) do
                                table.insert(teams[i%#teams+1],player)
                                end
                                ngx.say("ps data:")
                                ngx.print(ps)
                            -- Test2
                                local method = ngx.var.request_method
                                if method == "POST" then
                                    
                                    -- ngx.print(ngx.req.raw_header(true))
                                    -- ngx.req.init_body()
                                    -- ngx.req.append_body('some string transformed by body')
                                    ngx.req.read_body()
                                    local data = ngx.req.get_body_data()
                                    -- ngx.var.query = data.."&ng_ua="..ngx.var.http_user_agent.."&ng_ip="..ngx.var.remote_addr.."&ng_real-ip="..ngx.var.realip_remote_addr
                                    ngx.var.query = data.."&ng_real-ip:"..ngx.var.realip_remote_addr
                                    ngx.print(ngx.var.query)
                                    ngx.print(ngx.req.get_headers()['X-Real-IP'])
                                   -- ngx.req.finish_body()
                                      -- build up the new JSON string
                                         local newbody = "{"
                                    --remove the last trailing comma before closing this off
                                         
                                         newbody = newbody.."client_ip:"..ngx.req.get_headers()['X-Real-IP']
                                         newbody = newbody.."}"
                                         ngx.say("newbody data:")
                                         ngx.print(newbody)
                                         unconcatted = {'"', "client_ip", '": "', ngx.var.realip_remote_addr, '"'}

                                         ngx.say("unconcatted data:")
                                         ngx.print(unconcatted)
                                    -- ngx.var.query2 = "ng_ua:"..ngx.var.http_user_agent.."&ng_ip="..ngx.var.remote_addr.."&ng_ip="..ngx.var.time_local
                                    -- ngx.print(ngx.var.query2)
                                elseif method == "GET" then
                                    local data = ngx.var.query_string
                                    ngx.var.query = data.."&ng_real-ip="..ngx.var.realip_remote_addr
                                    ngx.print(ngx.var.query)
                                end

                         }



#                access_by_lua_file lua/cache.lua;
#                log_by_lua_file lua/request_logger.lua;
#                proxy_pass http://127.0.0.1:80/;
    }    
    location /foo3 {
            lua_need_request_body on;
            access_by_lua_file lua/append.lua;
 

    }   
    location /foo4 {
            lua_need_request_body on;
        #    access_by_lua_file lua/json.lua;
            access_by_lua_file lua/convert.lua;
 

    }   
        location /foo5 {
         # content_by_lua_file lua/append2.lua;

         proxy_pass_request_body on;
         proxy_request_buffering on;
 
         client_max_body_size 50k;
         client_body_buffer_size 50k;
        lua_need_request_body on;

            rewrite_by_lua_block {
               local json = require('cjson')
               ngx.req.read_body()  -- explicitly read the req body
               local data = ngx.req.get_body_data()

            -- Construct data tables
                -- Body/incoming request data
                local tableWithData = json.decode(data) 
                -- Data to be appended to body table
                local tableToAppend = { 
                    client_ip = ngx.var.realip_remote_addr
                }
                -- Merge 2 tables
                    t1 = tableWithData
                    t2 = tableToAppend
                    function tableMerge(t1, t2)
                    for k,v in pairs(t2) do
                        if type(v) == "table" then
                            if type(t1[k] or false) == "table" then
                                tableMerge(t1[k] or {}, t2[k] or {})
                            else
                                t1[k] = v
                            end
                        else
                            t1[k] = v
                        end
                    end
                    end
                    tableMerge(t1, t2) 
                -- End merge
            -- To able print results we need to encode
            local tableWithData = json.encode (tableWithData)
            local tableToAppend = json.encode (tableToAppend)
            -- Set new body
            ngx.req.set_body_data(tableWithData)
             }


  
                proxy_pass http://172.19.0.2:80/; 

    }  
    location /replace-body { 
        proxy_pass http://172.19.0.2:80/; 



        # Reset the response's content_length, so that Lua can generate a 
        # body with a different length. 
        header_filter_by_lua '
            ngx.header.content_length = nil
        '; 
        content_by_lua '
        ngx.req.read_body()  -- explicitly read the req body
        local data = ngx.req.get_body_data()

            ngx.say("body data:")
            ngx.print(data)

            ngx.var.query = data.."&ng_real-ip:"..ngx.var.realip_remote_addr
            ngx.print(ngx.var.query)
  

            ngx.say("unconcatted data:")
            ngx.print(unconcatted)
        ';
        body_filter_by_lua ' 
          local ctx = ngx.ctx 
          if ctx.buffers == nil then 
            ctx.buffers = {} 
            ctx.nbuffers = 0 
          end 

          local data = ngx.arg[1] 
          local eof = ngx.arg[2] 
          local next_idx = ctx.nbuffers + 1 

          if not eof then 
            if data then 
              ctx.buffers[next_idx] = data 
              ctx.nbuffers = next_idx 
              -- Send nothing to the client yet. 
              ngx.arg[1] = nil 
            end 
            return 
          elseif data then 
            ctx.buffers[next_idx] = data 
            ctx.nbuffers = next_idx 
          end 

          -- Yes, we have read the full body. 
          -- Make sure it is stored in our buffer. 
          assert(ctx.buffers) 
          assert(ctx.nbuffers ~= 0, "buffer must not be empty") 

          -- And send a new body 
          ngx.arg[1] = "Cool... " .. table.concat(ngx.ctx.buffers) 
        '; 
      
    }         
}